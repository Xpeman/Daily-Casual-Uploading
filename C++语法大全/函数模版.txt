#include <iostream>
using std::cout;
using std::endl;
struct MyPos
{
	int  x;
	int  y;
public:
	MyPos operator+(MyPos const &srcPos) const
	{
		MyPos tempPos;
		tempPos.x = x + srcPos.x;
		tempPos.y = y + srcPos.y;
		return tempPos;
	}

};
/*
函数模板:
关键字  -  template
模板函数的重载分两种：
1.模板函数与模板函数的重载
（1）一个函数参数列表的类型与个数不一样
（2）一个模板类型的列表个数不一样
2.模板函数与普通函数的重载
   参数的个数和类型不一样

   重载注意事项：
   1>如果实参和普通函数的实参完全匹配，优先调用普通函数
   2>如果不能完全匹配，去查找模板能否生成完全匹配的模板函数，如果是，调用模板函数
   3>如果不能完全匹配，查找的模板不能完全匹配模板函数，重新查找普通函数，看能否进行参数类型转换执行，如果可以调用普通函数，如果不可以则报错


模板的调用方式：
（1）隐示调用（通过函数的实参确定类型来推断参数列表中的T的类型）

（2）显示调用（必须制定实参类型是哪种数据类型）

*/
template <class T>
T MyAdd(T a, T b)
{
	return a + b;
}

//函数模板与函数模板重载，模板类型列表个数不一致
template <class T,class T1>
T MyAdd(T a,T b)
{
	return a + b;
}

//模板函数与模板函数重载，函数参数列表类型不一样
template <class T,class T1>
T1 MyAdd(T1 a,T1 b)
{
	return  a + b;
}

//模板函数与模板函数重载，函数参数列表个数不一样
template <class T>
T MyAdd(T a, T b, T c)
{
	return  a + b + c;
}
int main()
{

	MyAdd(2.0, 1.1);



	//p1+p2可以操作的原因已经做过了重载，p1,p2是MyPos的对象，内部存在重载函数可以相加操作
	MyPos p1 = { 1, 2 };
	MyPos p2 = { 3, 4 };
	cout << MyAdd(p1, p2).x << endl;//MyAdd的返回值就是一个MyPos类型结构，所以可以访问
	cout << MyAdd(p1, p2).y << endl;

	char a = 'a';
	char b = 'b';
	cout << MyAdd(a, b) << endl;
	cout << "Hello World" << endl;

	return  0;
}