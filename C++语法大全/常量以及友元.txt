/*
友元
类的封装性
友元：打破类的封装性


友元分为：友元函数和友元类


*/
//class CA
//{
//	int h;
//public:
//	void Seth(int h);
//	int GetH() const { return h; }
//	//特点：友元函数是一个普通函数，不是类成员函数，不受类的掌控，和static成员类似
//	//不管在类里面直接定义这个函数，还是在类外定义，都不属于类
//	friend void SetCAH(CA &a, int h);//友元函数，这个函数是这个类的朋友就可以访问私有成员h
//
//};
//
//void CA::Seth(int h)
//{
//	this->h = h;
//}
//
//void SetCAH(CA & a,int h)
//{
//	//在没加friend之前这样写会报错，h是私有成员在类外不能被访问，加了friend之后就可以访问了
//	a.h = h;
//}
//int main()
//{
//
//	CA npc;
//	SetCAH(npc, 10);
//
//	return 0;
//}



//友元类
class CB;//类的声明

class CA
{
	int h;
public:
	//CB类是CA类的朋友，友元类的声明
	friend class CB;
};

class CB
{
public:
	//加&的原因：用自身类型构造自身，避免造成无限递归，加&	
	void aa(CA&a);
	void bb(CA&a);
	void dd(CA&a);
};

void CB::aa(CA &a)
{
	//如果不声明CB是CA类的朋友，那么这样写会出错,私有成员在类外不能被访问，加了友元就行
	a.h = 10;
}

void CB::bb(CA &a)
{
	//如果不声明CB是CA类的朋友，那么这样写会出错
	a.h = 100;
}

void CB::dd(CA &a)
{
	//如果不声明CB是CA类的朋友，那么这样写会出错
	a.h = 100;
}

void main()
{
	

	//友元的特点：1.单方向  2.不传递  3.不继承
	CA a1, a2;
	CB b1, b2;
	//CB的任何一个对象，都是CA对象的朋友
	b1.aa(a1);
	b1.aa(a2);



}