/*
#include <stdio.h>
class CA
{
private:
	int a;
public:
	int b;
protected:
	int c;
public:
	CA(){ printf("CA\n"); }
	~CA(){ printf("~CA\n"); }


};

//派生不仅具备自身的内存，还具备基类的内存
class CB :public CA
{
public:
	int aa;
	CA aaaa;// a为子对象

	void aaa()
	{
		c += 10;//c为基类的保护类型，可以在派生类中直接访问，但不能在其他类中被访问，保护属性，只能在派生类中被访问
		b += 20;//公有成员不仅可以在派生类中被直接访问，也可以被其他类访问
		//a += 10;这种情况是不允许的，a是基类的私有成员，不管在派生类还是其他类都不允许被直接访问
	}

	CB(){ printf("CB\n"); }
	~CB(){ printf("~CB\n"); }
};

//派生类或者类在构造过程中的构造顺序：1.先构造基类  2.在构造子对象 3.在构造自身
//析构的过程反向





//基类如果必须构造带参构造函数，派生类必须提供显示的构造函数，且在成员初始化列表中去构造无名基类，并且只能在成员初始化列表中写
//派生类的子对象如果也必须带参构造，参照基类
class CX
{

	int x;
public:
	CX(int i){ x = i; }
	~CX();

};

class CY :public CX
{

	int y;
	CY() :CX(1){};
	~CY();


};



void main()
{

	//即使CB继承了CA，CA的私有成员数据在CB类中依然不能被访问
	CB b;



	/*printf("%d\n", sizeof(CA));
	printf("%d\n", sizeof(CB));*/

/*
}


*/






//多继承中：以声明顺序为主去构造基类（从左往右的声明顺序）
//类中有多个子对象，也是以声明顺序为止去构造（从上往下的声明顺序）
//多级继承构造顺序：1.构造基类，如果有多个基类（从左往右依次构造）
//                  2.构造子对象，如果有多个子对象，按声明顺序（从上往下）依次构造
//                  3.构造自身
//#include <stdio.h>
//class CX
//{
//	int x;
//public:
//	CX(int i){ x = i; printf("CX %d\n", x); }
//
//
//};
//
//class CY
//{
//	int y;
//public:
//	CY(int i){ y = i; printf("CY %d\n", y); }
//
//
//};
//
//class CM:public CX,public CY
//{
//	int m;
//	CX x;
//	CY y;
//public:
//	//加两个CX，CY是调用父类的构造，后面是对两个子对象的构造
//	CM(int i):CX(10),CY(20),x(1),y(2){ m = i; printf("CM\n"); }
//
//};
//
////派生类是基类对象，反之则不是
////访问成员数据的时候，不加限定访问，访问的都是派生类本身的数据
//void main()
//{
//	CM m(10);
//
//
//}





//#include <stdio.h>
////派生类是基类对象，反之则不是
////不加限定，访问的都是派生类本身的数据。
//class CA
//{
//
//public:
//	int a1;
//
//};
//
//class CB :public CA
//{
//
//public:
//	int a1;
//
//
//
//};
//
//void  main()
//{
//
//	CA a;
//	CB b;
//	//这样赋值可以的，派生类是基类对象
//	a = b;
//
//	b.a1;//访问的是CB类的a1
//	b.CA::a1;//这个就是限定访问，访问的是CA的a1
//
//
//
//
//}


#include <stdio.h>
//类没有虚实，继承才有虚实
//常见情况：在多级混合继承中，不出现多个同名基类
//虚基类
//关键字：virtual（在类中如果碰到virtual关键字，这个类的大小增加4字节，作用判断虚继承的时候，虚基类是否被构造过，如果构造过，那么虚基类不需要再次被构造）
class CA
{

public:
	CA(int i){ printf("CA\n"); }
	int a;

};

//virtual修饰继承关系，理解为虚继承
//在类的继承关系中只有虚基类的优先度最高，先构造
//类的构造顺序
//	1.构造虚基类，如果有多个虚基类，按照声明顺序（从左往右）依次构造
//  2.构造基类，如果有多个基类（从左往右依次构造）
//  3.构造子对象，如果有多个子对象，按照声明顺序（从上往下）依次构造
//  4.构造自身

class CB:virtual public CA//在没加virtual之前，CB是8个字节，加了virtual之后是12字节
{

public:
	int a;
	CB() :CA(10){ printf("CB\n"); }

};

class CD :virtual public CA
{
public:
	int a;
	CD() :CA(20){ printf("CD\n"); }

};

class CM :public CB, public CD
{
public:
	CM() :CA(30){ printf("CM\n"); }
	int a;
};


void main()
{

	CM m;
	m.a;//不加限定访问的都是自身的数据，访问的是CM的a
	m.CB::a;//这个就是访问的CB的a
	m.CD::a;//这个就是访问的CA的a
	m.CA::a;//这个会产生二义性，CB和CD都继承于CA，那么不清楚访问的是CB是CD的a
	m.CD::CA::a;//这个访问的也是CD的a
	m.CB::CA::a;//这个访问的也是CB的a

	//虚继承之后
	//1.虚基类内存在最后
	//2.虚基类只有一份在派生类内存中


	CM *pm = &m;
	//如果把CD取消虚继承CA
	//构造顺序为CA CB CA CD CM
	//构造m的时候，先去看有没有继承关系，有CB，发现CB虚继承于CA ，那么虚基类CA优先构造
	//然后在构造CB本身
	//在构造CD ，CD有没有基类有CA，并且实继承于CA，CA需要再次被构造，因为CD不在是虚继承于CA，所以还是需要构造CA
	//在构造CD本身
	//在构造CM本身


}