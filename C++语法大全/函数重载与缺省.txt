/*
函数的重载：用一个函数名来管理多个函数体
（1）函数名相同，参数列表的个数不同
（2）函数名相同，参数对应位置的类型不同



*/

/*
#include<stdio.h>
int MyAdd(int a,int b,int c)
{

	return a + b + c;
}

int MyAdd(int a,int b)
{

	return a + b;
}

float MyAdd(float a, float b)
{

	return a + b;
}

int main()
{
	int a,b;
	float c;
	a=MyAdd(1, 2,2);
	b=MyAdd(1, 1);
	c=MyAdd(1.1f,1.1);//调用第三个MyAdd，要加f，小数默认的是double类型，
                   	  //加个f为float类型，根据参数类型去调用相应的函数
	printf("%d\n", a);
	printf("%d\n", b);
	printf("%f\n", c);
	return 0;
}

*/

/*
函数的缺省：参数缺省
（1）在定义函数的时候，给形参初始值，那么调用的时候，就不需要再给实参，默认使用形参的初始值
（2）调用函数的时候，实参会覆盖形参
（3）参数缺省只能由后往前缺省，不能从前往后缺，也就是由后往前给形参值
（4）函数缺省和函数重载会产生二义性
（5）缺省函数的声明和定义要分开
*/

//#include <stdio.h>
//int MyAdd(int a = 1, int b = 1)
//{
//
//	return a + b;
//}
//
//double MyAdd(double a,double b=1.1)//缺省只能从后往前缺省
//{
//
//	return a + b;
//}
//
////int MyAdd(int a,int b)
////{
////
////	return a + b;
////}
//
////声明缺省函数
//int MyAdd1(int a, int b = 1);
//int main()
//{
//
//	int a,b;
////	b = MyAdd(3, 4);//实参的值会覆盖形参的值
//	//a = MyAdd();
//	
//	/*printf("%d\n", a);
//	printf("%d\n", b);*/
//
//	double c;
//	c = MyAdd(1.1);
//	printf("%lf\n", c);
//	//MyAdd();
//	//MyAdd(1,1);//这样会产生二义性，第一个MyAdd可以调用，会用实参覆盖形参，第三个也可以调用
//	int d;
//	d = MyAdd1(1);
//	printf("d=%d\n", d);
//	return  0;
//}
//
//
////缺省函数定义的时候就不需要缺省了，再声明的时候已经缺省了
//int MyAdd1(int a,int b)
//{
//	return a + b;
//}
//
//



/*
内联函数：inline关键字
概念：通过膨胀代码减少函数的跳转
内联函数MyAdd每次拷贝都会把函数内部的所有的代码全部拷贝，所以这是内联的坏处

所以内联一般仅用于简单的赋值或者直接返回数据使用内联,内联在类当中会使用，返回私有成员数据使用的较多




*/
#include <stdio.h>
inline int MyAdd(int a,int b)
{

	int temp = 0;
	for (int i = 0; i < 100; i++)
		temp += i;

	return a + b;
}
int main()
{
	//如果MyAdd不是内联函数，就会调用三次MyAdd函数跳转三次，每次调用都会申请8个字节内存，调用结束自动释放
	//MyAdd(1, 2);
	//MyAdd(10, 20);
	//MyAdd(100, 200);

	//加了inline变成内联函数
	MyAdd(1, 2);//将实参的值拷贝给形参  1+2
	MyAdd(10, 20);//将实参的值拷贝给形参  10+20
	MyAdd(100, 200);//将实参的值拷贝给形参  100+200

	return 0;
}